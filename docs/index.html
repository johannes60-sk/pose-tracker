<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Exercise Tracker</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #000; overflow: hidden; }

    #canvas-container {
      position: relative;
      width: 100vw;
      height: 100vh;
    }
    canvas {
      position: absolute;
      top: 0; left: 0;
      width: 100%;
      height: 100%;
    }

    #status {
      position: fixed;
      top: 20px;
      left: 0; right: 0;
      text-align: center;
      z-index: 10;
      pointer-events: none;
    }
    #status span {
      background: rgba(0,0,0,0.65);
      color: #fff;
      font: 500 13px/1 -apple-system, sans-serif;
      padding: 6px 18px;
      border-radius: 99px;
    }

    #hud {
      position: fixed;
      bottom: 30px;
      left: 0; right: 0;
      display: flex;
      justify-content: center;
      gap: 10px;
      z-index: 10;
      pointer-events: none;
    }
    .badge {
      background: rgba(0,0,0,0.65);
      color: #fff;
      font: 600 14px/1 -apple-system, sans-serif;
      padding: 9px 18px;
      border-radius: 99px;
      border: 1.5px solid rgba(255,255,255,0.2);
    }
    .badge.reps     { border-color: #00FF88; }
    .badge.position { border-color: #4488FF; }
    .badge.conf     { border-color: #FFB800; }

    #error-msg {
      display: none;
      position: fixed;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(200,0,0,0.85);
      color: #fff;
      font: 500 14px/1.5 -apple-system, sans-serif;
      padding: 16px 24px;
      border-radius: 12px;
      text-align: center;
      z-index: 20;
      max-width: 80%;
    }
  </style>
</head>
<body>
  <div id="canvas-container">
    <canvas id="canvas"></canvas>
  </div>

  <div id="status"><span id="status-text">Chargement du modèle IA...</span></div>
  <div id="hud">
    <div class="badge reps"     id="reps-badge">Reps : 0</div>
    <div class="badge position" id="pos-badge">— —</div>
    <div class="badge conf"     id="conf-badge">Conf : —</div>
  </div>
  <div id="error-msg"></div>

  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.3.1/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@teachablemachine/pose@0.8/dist/teachablemachine-pose.min.js"></script>

  <script>
    // ─── Params URL ────────────────────────────────────────────────────────────
    // ?exercise=push_up&model=https://teachablemachine.withgoogle.com/models/XXXXX/
    const params   = new URLSearchParams(window.location.search);
    const EXERCISE = params.get('exercise') || 'push_up';
    const MODEL_URL = params.get('model');

    // ─── Communication vers React Native ──────────────────────────────────────
    function send(data) {
      const msg = JSON.stringify(data);
      if (window.ReactNativeWebView) {
        window.ReactNativeWebView.postMessage(msg);
      } else {
        window.parent.postMessage(data, '*');
      }
    }

    function setStatus(txt) {
      document.getElementById('status-text').textContent = txt;
    }

    function showError(msg) {
      const el = document.getElementById('error-msg');
      el.style.display = 'block';
      el.textContent = msg;
      setStatus('Erreur');
    }

    // ─── Vérification du model URL ─────────────────────────────────────────────
    if (!MODEL_URL) {
      showError('Aucun modèle configuré.\nAjoute ?model=URL dans l\'URL.');
    }

    // ─── Comptage de reps ──────────────────────────────────────────────────────
    const CONFIDENCE_THRESHOLD = 0.75; // seuil de confiance minimum
    let currentClass = 'neutral';
    let repCount     = 0;
    let lastCount    = -1;

    function processClassification(predictions) {
      // Trouve la classe avec la plus haute probabilité
      const best = predictions.reduce((a, b) =>
        a.probability > b.probability ? a : b
      );

      const predicted = best.probability >= CONFIDENCE_THRESHOLD
        ? best.className
        : 'neutral';

      const conf = (best.probability * 100).toFixed(0);
      document.getElementById('conf-badge').textContent = 'Conf : ' + conf + '%';
      document.getElementById('pos-badge').textContent  = predicted.toUpperCase();

      // Transition down → up = 1 rep
      if (currentClass === 'down' && predicted === 'up') {
        repCount++;
        document.getElementById('reps-badge').textContent = 'Reps : ' + repCount;
        if (repCount !== lastCount) {
          lastCount = repCount;
          send({ type: 'counter', current_count: repCount });
        }
      }

      if (predicted !== currentClass) {
        currentClass = predicted;
        const ready = predicted !== 'neutral';
        send({ type: 'posture', ready, postureDirection: predicted });
      }
    }

    // ─── Init Teachable Machine ────────────────────────────────────────────────
    async function init() {
      if (!MODEL_URL) return;

      try {
        setStatus('Chargement du modèle...');
        const model = await tmPose.load(
          MODEL_URL + 'model.json',
          MODEL_URL + 'metadata.json'
        );

        setStatus('Accès caméra...');
        const webcam = new tmPose.Webcam(
          window.innerWidth,
          window.innerHeight,
          true // flip (selfie)
        );
        await webcam.setup();
        await webcam.play();

        send({ type: 'initialization', exercise: EXERCISE, ready: true });
        setStatus(EXERCISE.replace(/_/g, ' ').toUpperCase() + ' — Prêt !');

        const canvasEl = document.getElementById('canvas');
        canvasEl.width  = window.innerWidth;
        canvasEl.height = window.innerHeight;
        const ctx = canvasEl.getContext('2d');

        async function loop() {
          webcam.update();

          // Dessin de la vidéo
          ctx.drawImage(webcam.canvas, 0, 0, canvasEl.width, canvasEl.height);

          // Estimation de pose + classification
          const { pose, posenetOutput } = await model.estimatePose(webcam.canvas);
          const predictions = await model.predict(posenetOutput);

          // Dessin du squelette
          if (pose && pose.keypoints) {
            drawKeypoints(ctx, pose.keypoints);
            drawSkeleton(ctx, pose.keypoints);
          }

          processClassification(predictions);
          window.requestAnimationFrame(loop);
        }

        loop();

      } catch (err) {
        showError('Erreur : ' + err.message);
        send({ type: 'error', message: err.message });
      }
    }

    // ─── Dessin du squelette ───────────────────────────────────────────────────
    const SKELETON_PAIRS = [
      [5,6],[5,7],[7,9],[6,8],[8,10],
      [5,11],[6,12],[11,12],
      [11,13],[13,15],[12,14],[14,16],
    ];

    function drawKeypoints(ctx, keypoints) {
      keypoints.forEach(kp => {
        if (kp.score > 0.4) {
          ctx.beginPath();
          ctx.arc(
            kp.position.x * (canvasEl.width  / webcamWidth),
            kp.position.y * (canvasEl.height / webcamHeight),
            5, 0, 2 * Math.PI
          );
          ctx.fillStyle = '#FF4444';
          ctx.fill();
        }
      });
    }

    function drawSkeleton(ctx, keypoints) {
      SKELETON_PAIRS.forEach(([i, j]) => {
        const kpA = keypoints[i];
        const kpB = keypoints[j];
        if (kpA.score > 0.4 && kpB.score > 0.4) {
          ctx.beginPath();
          ctx.moveTo(
            kpA.position.x * (canvasEl.width  / webcamWidth),
            kpA.position.y * (canvasEl.height / webcamHeight)
          );
          ctx.lineTo(
            kpB.position.x * (canvasEl.width  / webcamWidth),
            kpB.position.y * (canvasEl.height / webcamHeight)
          );
          ctx.strokeStyle = '#00FF88';
          ctx.lineWidth = 2;
          ctx.stroke();
        }
      });
    }

    // Dimensions du webcam Teachable Machine (pour le scaling du squelette)
    const webcamWidth  = window.innerWidth;
    const webcamHeight = window.innerHeight;
    const canvasEl     = document.getElementById('canvas');

    init();
  </script>
</body>
</html>
